//! A library for the privileged tunnel process for a Linux Firezone Client
//!
//! This is built both standalone and as part of the GUI package. Building it
//! standalone is faster and skips all the GUI dependencies. We can use that build for
//! CLI use cases.
//!
//! Building it as a binary within the `gui-client` package allows the
//! Tauri deb bundler to pick it up easily.
//! Otherwise we would just make it a normal binary crate.

use std::path::PathBuf;

pub use imp::{default_token_path, run};

#[cfg(target_os = "linux")]
mod imp_linux;
#[cfg(target_os = "linux")]
use imp_linux as imp;

#[cfg(target_os = "windows")]
mod imp_windows {
    use clap::Parser;

    pub fn default_token_path() -> std::path::PathBuf {
        todo!()
    }

    pub async fn run() -> anyhow::Result<()> {
        let cli = super::Cli::parse();
        let _cmd = cli.command();
        Ok(())
    }
}
#[cfg(target_os = "windows")]
use imp_windows as imp;

#[derive(clap::Parser)]
#[command(author, version, about, long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Option<Cmd>,

    #[arg(
        short = 'u',
        long,
        hide = true,
        env = "FIREZONE_API_URL",
        default_value = "wss://api.firezone.dev"
    )]
    pub api_url: url::Url,

    /// Token generated by the portal to authorize websocket connection.

    // TODO: It isn't good for security to pass the token as a CLI arg.
    // If we pass it as an env var, we should remove it immediately so that
    // other processes don't see it. Reading it from a file is probably safest.
    #[arg(long, env = "FIREZONE_TOKEN")]
    pub token: Option<String>,

    /// A filesystem path where the token can be found
    #[arg(default_value_t = default_token_path().display().to_string(), env = "FIREZONE_TOKEN_PATH", long)]
    token_path: String,

    /// Identifier used by the portal to identify and display the device.

    // AKA `device_id` in the Windows and Linux GUI clients
    // Generated automatically if not provided
    #[arg(short = 'i', long, env = "FIREZONE_ID")]
    pub firezone_id: Option<String>,

    /// File logging directory. Should be a path that's writeable by the current user.
    #[arg(short, long, env = "LOG_DIR")]
    log_dir: Option<PathBuf>,

    /// Maximum length of time to retry connecting to the portal if we're having internet issues or
    /// it's down. Accepts human times. e.g. "5m" or "1h" or "30d".
    #[arg(short, long, env = "MAX_PARTITION_TIME")]
    max_partition_time: Option<humantime::Duration>,
}

impl Cli {
    fn command(&self) -> Cmd {
        // Needed for backwards compatibility with old Docker images
        self.command.unwrap_or(Cmd::Auto)
    }
}

#[derive(clap::Subcommand, Clone, Copy)]
enum Cmd {
    /// If there is a token on disk, run in standalone mode. Otherwise, run as an IPC service. This will be removed in a future version.
    #[command(hide = true)]
    Auto,
    /// Listen for IPC connections and act as a privileged tunnel process for a GUI client
    #[command(hide = true)]
    IpcService,
    /// Act as a CLI-only Client
    Standalone,
    /// Act as an IPC client for development
    #[command(hide = true)]
    StubIpcClient,
}
