use connlib_shared::{
    linux::{ETC_RESOLV_CONF, ETC_RESOLV_CONF_BACKUP},
    Error, Result,
};
use std::{net::IpAddr, path::Path};
use tokio::io::AsyncWriteExt;

/// Back up `/etc/resolve.conf` and then modify it in-place
pub async fn configure_dns(dns_config: &[IpAddr]) -> Result<()> {
    configure_dns_at_paths(
        dns_config,
        Path::new(ETC_RESOLV_CONF),
        Path::new(ETC_RESOLV_CONF_BACKUP),
    )
    .await
}

async fn configure_dns_at_paths(
    dns_config: &[IpAddr],
    resolv_path: &Path,
    backup_path: &Path,
) -> Result<()> {
    if dns_config.is_empty() {
        tracing::info!("`dns_config` is empty, leaving `/etc/resolv.conf` unchanged");
        return Ok(());
    }

    let text = tokio::fs::read_to_string(resolv_path)
        .await
        .map_err(Error::ReadResolvConf)?;
    let parsed = resolv_conf::Config::parse(&text).map_err(|_| Error::ParseResolvConf)?;

    // Back up the original resolv.conf. If there's already a backup, don't modify it
    match tokio::fs::File::options()
        .write(true)
        .create_new(true)
        .open(backup_path)
        .await
    {
        Err(error) if error.kind() == std::io::ErrorKind::AlreadyExists => {
            tracing::info!(?backup_path, "Backup path already exists, won't overwrite");
        }
        Err(error) => return Err(Error::WriteResolvConfBackup(error)),
        // TODO: Would do a rename-into-place here if the contents of the file mattered more
        Ok(mut f) => f.write_all(text.as_bytes()).await?,
    }

    // TODO: Would do an fsync here if resolv.conf was important and not
    // auto-generated by Docker on every run.

    let mut new_resolv_conf = parsed.clone();
    new_resolv_conf.nameservers = dns_config.iter().map(|addr| (*addr).into()).collect();

    // Over-writing `/etc/resolv.conf` actually violates Docker's plan for handling DNS
    // https://docs.docker.com/network/#dns-services
    // But this is just a hack to get a smoke test working in CI for now.
    //
    // Because Docker bind-mounts resolv.conf into the container, (visible in `mount`) we can't
    // use the rename trick to safely update it, nor can we delete it. The best
    // we can do is rewrite it in-place.
    let new_text = format!(
        r"
# Generated by the Firezone client
# The original is at {}
{}
",
        backup_path.display(),
        new_resolv_conf,
    );

    tokio::fs::write(resolv_path, new_text)
        .await
        .map_err(Error::RewriteResolvConf)?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::configure_dns_at_paths;
    use anyhow::{ensure, Context, Result};
    use std::{
        net::{IpAddr, Ipv4Addr, Ipv6Addr},
        path::Path,
    };

    const GOOGLE_DNS: Ipv4Addr = Ipv4Addr::new(8, 8, 8, 8);

    const DEBIAN_VM_RESOLV_CONF: &str = r#"
# This is /run/systemd/resolve/stub-resolv.conf managed by man:systemd-resolved(8).
# Do not edit.
#
# This file might be symlinked as /etc/resolv.conf. If you're looking at
# /etc/resolv.conf and seeing this text, you have followed the symlink.
#
# This is a dynamic resolv.conf file for connecting local clients to the
# internal DNS stub resolver of systemd-resolved. This file lists all
# configured search domains.
#
# Run "resolvectl status" to see details about the uplink DNS servers
# currently in use.
#
# Third party programs should typically not access this file directly, but only
# through the symlink at /etc/resolv.conf. To manage man:resolv.conf(5) in a
# different way, replace this symlink by a static file or a different symlink.
#
# See man:systemd-resolved.service(8) for details about the supported modes of
# operation for /etc/resolv.conf.
nameserver 127.0.0.53
options edns0 trust-ad
search .
"#;

    // Docker seems to have injected the WSL host's resolv.conf into the Alpine container
    // Also the nameserver is changed for privacy
    const ALPINE_CONTAINER_RESOLV_CONF: &str = r#"
# This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to /etc/wsl.conf:
# [network]
# generateResolvConf = false
nameserver 9.9.9.9
"#;

    // From a Debian desktop
    const NETWORK_MANAGER_RESOLV_CONF: &str = r"
# Generated by NetworkManager
nameserver 192.168.1.1
nameserver 2001:db8::%eno1
";

    #[test]
    fn parse_resolv_conf() {
        let parsed = resolv_conf::Config::parse(DEBIAN_VM_RESOLV_CONF).unwrap();
        let mut config = resolv_conf::Config::new();
        config
            .nameservers
            .push(resolv_conf::ScopedIp::V4(Ipv4Addr::new(127, 0, 0, 53)));
        config.set_search(vec![".".into()]);
        config.edns0 = true;
        config.trust_ad = true;
        assert_eq!(parsed, config);

        let parsed = resolv_conf::Config::parse(ALPINE_CONTAINER_RESOLV_CONF).unwrap();
        let mut config = resolv_conf::Config::new();
        config
            .nameservers
            .push(resolv_conf::ScopedIp::V4(Ipv4Addr::new(9, 9, 9, 9)));
        assert_eq!(parsed, config);

        let parsed = resolv_conf::Config::parse(NETWORK_MANAGER_RESOLV_CONF).unwrap();
        let mut config = resolv_conf::Config::new();
        config
            .nameservers
            .push(resolv_conf::ScopedIp::V4(Ipv4Addr::new(192, 168, 1, 1)));
        config.nameservers.push(resolv_conf::ScopedIp::V6(
            Ipv6Addr::new(
                0x2001, 0x0db8, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
            ),
            Some("eno1".into()),
        ));
        assert_eq!(parsed, config);

        assert!(resolv_conf::Config::parse("").is_ok());
        assert!(resolv_conf::Config::parse("An invalid resolv.conf file.").is_err());
    }

    #[test]
    fn print_resolv_conf() {
        let mut new_resolv_conf = resolv_conf::Config::new();
        for addr in [
            IpAddr::from([100, 100, 111, 1]),
            IpAddr::from([100, 100, 111, 2]),
        ] {
            new_resolv_conf.nameservers.push(addr.into());
        }

        let actual = new_resolv_conf.to_string();
        assert_eq!(
            actual,
            r"nameserver 100.100.111.1
nameserver 100.100.111.2
"
        );
    }

    /// Returns `Ok(())` if the file at the given path contains the expected sentinels
    ///
    /// Return `Err(_)` if the file can't be parsed, the sentinels don't match, or
    /// any DNS options are set in the file.
    fn check_resolv_conf(path: &Path, expected_sentinels: &[IpAddr]) -> Result<()> {
        let text = std::fs::read_to_string(path).context("could not read file")?;
        let parsed = resolv_conf::Config::parse(text)?;

        let mut expected = resolv_conf::Config::new();
        expected_sentinels
            .iter()
            .for_each(|addr| expected.nameservers.push((*addr).into()));

        ensure!(
            parsed == expected,
            "Parsed resolv config didn't match expected resolv config"
        );
        Ok(())
    }

    // Not shared with prod code because prod also writes the "Generated by" comment,
    fn write_resolv_conf(path: &Path, nameservers: &[IpAddr]) -> Result<()> {
        let mut conf = resolv_conf::Config::new();
        conf.nameservers = nameservers.iter().map(|addr| (*addr).into()).collect();
        std::fs::write(path, conf.to_string())?;
        Ok(())
    }

    /// The original resolv.conf should be backed up, and the new one should only
    /// contain our sentinels.
    #[tokio::test]
    async fn resolv_conf_happy_path() -> Result<()> {
        // Try not to panic, it may leave temp files behind
        // Using `TempDir` instead of `tempfile` because I need the path, and instead
        // of `NamedTempFile` because those get deleted immediately on Linux, which confuses
        // `configure_dns_at_paths when it tries to read from the path.
        let temp_dir = tempfile::TempDir::with_prefix("firezone-dns-test")?;

        let resolv_path = temp_dir.path().join("resolv.conf");
        let backup_path = temp_dir.path().join("resolv.conf.firezone-backup");

        write_resolv_conf(&resolv_path, &[GOOGLE_DNS.into()])?;

        configure_dns_at_paths(
            &[IpAddr::from([100, 100, 111, 1])],
            &resolv_path,
            &backup_path,
        )
        .await?;

        check_resolv_conf(&resolv_path, &[IpAddr::from([100, 100, 111, 1])])
            .context("{resolv_path}")?;
        check_resolv_conf(&backup_path, &[GOOGLE_DNS.into()]).context("{backup_path}")?;

        Ok(())
    }

    /// If there are no sentinels for some reason, don't change resolv.conf
    #[tokio::test]
    async fn resolv_conf_no_sentinels() -> Result<()> {
        let temp_dir = tempfile::TempDir::with_prefix("firezone-dns-test")?;

        let resolv_path = temp_dir.path().join("resolv.conf");
        let backup_path = temp_dir.path().join("resolv.conf.firezone-backup");

        write_resolv_conf(&resolv_path, &[GOOGLE_DNS.into()])?;

        configure_dns_at_paths(&[], &resolv_path, &backup_path).await?;

        check_resolv_conf(&resolv_path, &[GOOGLE_DNS.into()]).context("{resolv_path}")?;
        ensure!(Path::try_exists(&backup_path)? == false);

        Ok(())
    }

    /// If we run twice, don't overwrite the resolv.conf backup
    #[tokio::test]
    async fn resolv_conf_twice() -> Result<()> {
        let temp_dir = tempfile::TempDir::with_prefix("firezone-dns-test")?;

        let resolv_path = temp_dir.path().join("resolv.conf");
        let backup_path = temp_dir.path().join("resolv.conf.firezone-backup");

        write_resolv_conf(&resolv_path, &[GOOGLE_DNS.into()])?;

        configure_dns_at_paths(
            &[IpAddr::from([100, 100, 111, 1])],
            &resolv_path,
            &backup_path,
        )
        .await?;

        configure_dns_at_paths(
            &[IpAddr::from([100, 100, 111, 2])],
            &resolv_path,
            &backup_path,
        )
        .await?;

        check_resolv_conf(&resolv_path, &[IpAddr::from([100, 100, 111, 2])])
            .context("{resolv_path}")?;
        check_resolv_conf(&backup_path, &[GOOGLE_DNS.into()]).context("{backup_path}")?;

        Ok(())
    }
}
