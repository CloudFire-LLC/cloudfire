name: Continuous Integration
on:
  pull_request:
  merge_group:
    types: [checks_requested]
  workflow_call:

# Cancel old workflow runs if new code is pushed
concurrency:
  group: "ci-${{ github.workflow }}-${{ github.ref }}"
  cancel-in-progress: true

jobs:
  elixir:
    uses: ./.github/workflows/_elixir.yml
  rust:
    uses: ./.github/workflows/_rust.yml
  kotlin:
    uses: ./.github/workflows/_kotlin.yml
    secrets: inherit
  swift:
    uses: ./.github/workflows/_swift.yml
    secrets: inherit
  static-analysis:
    uses: ./.github/workflows/_static-analysis.yml
  terraform:
    uses: ./.github/workflows/_terraform.yml
    secrets: inherit
  codeql:
    uses: ./.github/workflows/_codeql.yml
    secrets: inherit

  # We could build these in GCP with Cloud Build, but for now it's
  # less overhead to keep things in GH actions. See work on building these
  # in GCP with Cloud Build: https://github.com/firezone/firezone/pull/2234
  build-images:
    name: build-images-${{ matrix.image_name }}
    runs-on: ubuntu-22.04
    strategy:
      matrix:
        include:
          - image_name: api
            target: runtime
            context: elixir
            build-args: |
              APPLICATION_NAME=api
          - image_name: web
            target: runtime
            context: elixir
            build-args: |
              APPLICATION_NAME=web
          - image_name: gateway
            target: debug
            context: rust
            build-args: |
              PACKAGE=firezone-gateway
          - image_name: relay
            target: debug
            context: rust
            build-args: |
              PACKAGE=firezone-relay
          - image_name: client
            target: debug
            context: rust
            build-args: |
              PACKAGE=firezone-linux-client
          - image_name: snownet-tests
            target: debug
            context: rust
            build-args: |
              PACKAGE=snownet-tests
          - image_name: elixir
            target: compiler
            context: elixir
            build-args: |
              APPLICATION_NAME=api
    permissions:
      contents: read
      id-token: write
    env:
      # mark:automatic-version
      VERSION: "1.0.0"
      APPLICATION_NAME: ${{ matrix.image_name }}
    steps:
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          # We are overriding the default buildkit version being used by Buildx. We need buildkit >= 12.0 and currently BuildX
          # supports v0.11.6 https://github.com/docker/buildx/blob/b8739d74417f86aa8fc9aafb830a8ba656bdef0e/Dockerfile#L9.
          # We should for any updates on buildx and on the setup-buildx-action itself.
          driver-opts: |
            image=moby/buildkit:v0.12.0
      - uses: actions/checkout@v4
      - name: Sanitize github.ref_name
        run: |
          # `ref_name` contains `/` which is not a valid docker image tag
          REF="${{ github.ref_name }}"
          CACHE_TAG="${REF//\//-}"
          echo "CACHE_TAG=$CACHE_TAG" >> "$GITHUB_ENV"
          echo "BRANCH_TAG=$CACHE_TAG" >> "$GITHUB_ENV"
      - uses: ./.github/actions/gcp-docker-login
        id: login
        with:
          project: firezone-staging
      - name: Build Docker Tags
        id: build_docker_tags
        run: |
          set -xe

          TAGS=""

          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            MAJOR_VERSION="${VERSION%%.*}"
            MAJOR_MINOR_VERSION="${VERSION%.*}"

            TAGS="${TAGS},${{ steps.login.outputs.registry }}/firezone/${{ matrix.image_name }}:${MAJOR_VERSION}"
            TAGS="${TAGS},${{ steps.login.outputs.registry }}/firezone/${{ matrix.image_name }}:${MAJOR_MINOR_VERSION}"
            TAGS="${TAGS},${{ steps.login.outputs.registry }}/firezone/${{ matrix.image_name }}:${{ env.VERSION }}-${{ github.sha }}"
          fi

          TAGS="${TAGS},${{ steps.login.outputs.registry }}/firezone/${{ matrix.image_name }}:${{ env.BRANCH_TAG }}"
          TAGS="${TAGS},${{ steps.login.outputs.registry }}/firezone/${{ matrix.image_name }}:${{ github.sha }}"

          echo "tags=$TAGS" >> "$GITHUB_OUTPUT"
      - name: Build Docker images
        uses: docker/build-push-action@v5
        with:
          platforms: linux/amd64
          build-args: ${{ matrix.build-args }}
          context: ${{ matrix.context }}/
          cache-from: |
            type=registry,ref=${{ steps.login.outputs.registry }}/cache/${{ matrix.image_name }}:${{ env.CACHE_TAG }}
            type=registry,ref=${{ steps.login.outputs.registry }}/cache/${{ matrix.image_name }}:main
          # This will write the cache on main even if integration tests fail,
          # but it'll just be corrected on the next successful build.
          cache-to: |
            type=registry,ref=${{steps.login.outputs.registry}}/cache/${{ matrix.image_name}}:${{ env.CACHE_TAG }},mode=max
          file: ${{ matrix.context }}/Dockerfile
          push: true
          target: ${{ matrix.target }}
          tags: ${{ steps.build_docker_tags.outputs.tags }}

  snownet-integration-tests:
    name: snownet-integration-tests-${{ matrix.name }}
    needs: build-images
    runs-on: ubuntu-22.04
    permissions:
      contents: read
      id-token: write
      pull-requests: write
    env:
      VERSION: ${{ github.sha }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - file: docker-compose.lan.yml
            name: lan
          - file: docker-compose.wan-hp.yml
            name: wan-hp
          - file: docker-compose.wan-relay.yml
            name: wan-relay
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/gcp-docker-login
        id: login
        with:
          project: firezone-staging
      - name: Run ${{ matrix.file }} test
        run: |
          sudo sysctl -w vm.overcommit_memory=1
          timeout 600 docker compose -f rust/snownet-tests/${{ matrix.file }} up --exit-code-from dialer --abort-on-container-exit

  integration-tests:
    name: integration-tests-${{ matrix.test }}
    needs: build-images
    runs-on: ubuntu-22.04
    permissions:
      contents: read
      id-token: write
      pull-requests: write
    env:
      VERSION: ${{ github.sha }}
    strategy:
      fail-fast: false
      matrix:
        test: [
          direct-curl-portal-restart,
          relayed-curl-portal-restart,
          direct-curl-portal-down,
          relayed-curl-portal-down,
          direct-curl-portal-relay-down,
          dns-etc-resolvconf,
          dns-nm,
          systemd/dns-systemd-resolved,
        ]
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/gcp-docker-login
        id: login
        with:
          project: firezone-staging
      - name: Seed database
        run: docker compose run elixir /bin/sh -c 'cd apps/domain && mix ecto.seed'
      - name: Start docker compose in the background
        run: |
          # TODO: Order matters here, but it shouldn't. There seems to be some race
          # condition involved in letting Docker deterime the start order here.
          docker compose up -d dns.httpbin httpbin
          docker compose up -d api web
          docker compose up -d relay
          docker compose up -d gateway
          docker compose up -d client

      - run: ./scripts/tests/${{ matrix.test }}.sh

      - name: Show Client logs
        if: "!cancelled()"
        run: docker compose logs client
      - name: Show Relay logs
        if: "!cancelled()"
        run: docker compose logs relay
      - name: Show Gateway logs
        if: "!cancelled()"
        run: docker compose logs gateway
      - name: Show API logs
        if: "!cancelled()"
        run: docker compose logs api

  performance-tests:
    name: performance-tests-${{ matrix.test_name }}
    needs: build-images
    runs-on: ubuntu-22.04
    permissions:
      contents: read
      id-token: write
      pull-requests: write
    env:
      VERSION: ${{ github.sha }}
    strategy:
      fail-fast: false
      matrix:
        test_number: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]
        include:
          - test_name: direct-perf
            setup: echo 'Noop'
          - test_name: relayed-perf
            setup: |
              #  Disallow traffic between gateway and client container
              sudo iptables -I FORWARD 1 -s 172.28.0.100 -d 172.28.0.105 -j DROP
              sudo iptables -I FORWARD 1 -s 172.28.0.105 -d 172.28.0.100 -j DROP

    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/gcp-docker-login
        id: login
        with:
          project: firezone-staging
      - name: Seed database
        run:
          docker compose run elixir /bin/sh -c 'cd apps/domain && mix ecto.seed'
      - name: Start docker compose in the background
        run: |
          # We need to increase the log level to make sure that they don't hold off storm of packets
          # generated by UDP tests. Wire is especially chatty.
          sed -i 's/^\(\s*\)RUST_LOG:.*$/\1RUST_LOG: wire=error,info/' docker-compose.yml
          cat docker-compose.yml | grep RUST_LOG

          # TODO: Order matters here, but it shouldn't. There seems to be some race
          # condition involved in letting Docker deterime the start order here.
          docker compose up -d iperf3
          docker compose up -d api web
          docker compose up -d relay
          docker compose up -d gateway
          docker compose up -d client

      - name: 'Setup test: ${{ matrix.test_name }}'
        run: ${{ matrix.setup }}
      - name: 'Performance test: ${{ matrix.test_name }}'
        id: performance-test
        timeout-minutes: 5
        run: ./scripts/tests/perf/test.sh
      - name: 'Save performance test results: ${{ matrix.test_name }}'
        uses: actions/upload-artifact@v4
        with:
          name: '${{ matrix.test_name }}-iperf3results'
          path: ./iperf3results
      - name: 'Download main branch performance test results: ${{ matrix.test_name }}'
        id: download-artifact
        if: ${{ github.event_name == 'pull_request' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -xe

          REPO="${{ github.repository }}"
          WORKFLOW="cd.yml"
          ARTIFACT_NAME="${{ matrix.test_name }}-iperf3results"
          DESTINATION="./iperf3results-main"

          ARTIFACTS_URL=$(
            gh api \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "/repos/${REPO}/actions/workflows/${WORKFLOW}/runs?event=push&branch=main&status=success&per_page=1" \
              --jq ".workflow_runs[0].artifacts_url"
          )

          DOWNLOAD_URL=$(
            gh api \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "${ARTIFACTS_URL}" \
              --jq '.artifacts[] | select(.name == "'${ARTIFACT_NAME}'") | .archive_download_url'
          )

          set +x
          curl -H "Accept: application/vnd.github+json" -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" -L -o "${DESTINATION}.zip" "$DOWNLOAD_URL"

          set -x
          unzip "${DESTINATION}.zip" -d "${DESTINATION}"
          rm "${DESTINATION}.zip"
      - name: Update PR with results
        uses: actions/github-script@v7
        id: perf-comment
        if: ${{ github.event_name == 'pull_request' }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { script } = require('./scripts/tests/perf/results.js');
            script(github, context, '${{ matrix.test_name }}');
      - name: Show Client logs
        if: "!cancelled()"
        run: docker compose logs client
      - name: Show Relay logs
        if: "!cancelled()"
        run: docker compose logs relay
      - name: Show Gateway logs
        if: "!cancelled()"
        run: docker compose logs gateway
      - name: Show API logs
        if: "!cancelled()"
        run: docker compose logs api
      - name: Show iperf3 logs
        if: "!cancelled()"
        run: docker compose logs iperf3
