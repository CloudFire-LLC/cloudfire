name: Continuous Integration
on:
  push:
    branches:
      - main
  pull_request:
  merge_group:
    types: [checks_requested]
  workflow_call:

jobs:
  elixir:
    uses: ./.github/workflows/elixir.yml
  rust:
    uses: ./.github/workflows/rust.yml
  kotlin:
    uses: ./.github/workflows/kotlin.yml
  swift:
    uses: ./.github/workflows/swift.yml
  static-analysis:
    uses: ./.github/workflows/static-analysis.yml
  terraform:
    uses: ./.github/workflows/terraform.yml
    secrets: inherit

  # We could build these in GCP with Cloud Build, but for now it's
  # less overhead to keep things in GH actions. See work on building these
  # in GCP with Cloud Build: https://github.com/firezone/firezone/pull/2234
  build-images:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - image_name: api
            target: runtime
            cache_scope: elixir
            build-args: |
              APPLICATION_NAME=api
          - image_name: web
            target: runtime
            cache_scope: elixir
            build-args: |
              APPLICATION_NAME=web
          - image_name: gateway
            target: runtime
            cache_scope: rust
            build-args: |
              PACKAGE=firezone-gateway
          - image_name: relay
            target: runtime
            cache_scope: rust
            build-args: |
              PACKAGE=relay
          - image_name: client
            target: runtime
            cache_scope: rust
            build-args: |
              PACKAGE=firezone-headless-client
          - image_name: elixir
            target: builder
            cache_scope: elixir
            build-args: |
              APPLICATION_NAME=api
    permissions:
      contents: read
      id-token: write
    env:
      # mark:automatic-version
      VERSION: "1.20231001.0"
      APPLICATION_NAME: ${{ matrix.image_name }}
      GCP_PROJECT: firezone-staging
      GCP_REGISTRY: us-east1-docker.pkg.dev
    steps:
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - uses: actions/checkout@v4
      - name: Build Docker images
        uses: docker/build-push-action@v5
        with:
          platforms: linux/amd64
          build-args: ${{ matrix.build-args }}
          context: ${{ matrix.cache_scope }}/
          cache-from: type=gha,scope=${{ matrix.cache_scope }}
          # This will write the cache on main even if integration tests fail,
          # but it'll just be corrected on the next successful build.
          cache-to:
            ${{ github.ref == 'refs/heads/main' &&
            format('type=gha,mode=max,scope={0}', matrix.cache_scope) || '' }}
          file: ${{ matrix.cache_scope }}/Dockerfile
          # pushing is handled in a later step; this action doesn't allow output and push
          # in the same step :-/
          push: false
          target: ${{ matrix.target }}
          tags: |
            ${{ env.GCP_REGISTRY }}/${{ env.GCP_PROJECT }}/firezone/${{ matrix.image_name }}:${{ env.VERSION }}
            ${{ env.GCP_REGISTRY }}/${{ env.GCP_PROJECT }}/firezone/${{ matrix.image_name }}:${{ github.sha }}
            ${{ env.GCP_REGISTRY }}/${{ env.GCP_PROJECT }}/firezone/${{ matrix.image_name }}:latest
          outputs: type=docker,dest=/tmp/${{ matrix.image_name }}.tar
      - name: Upload built images as artifacts
        uses: actions/upload-artifact@v3
        with:
          name: images
          path: /tmp/${{ matrix.image_name }}.tar

  integration-tests:
    needs: build-images
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - test_name: Relayed flow
            setup: |
              #  Disallow traffic between gateway and client container
              sudo iptables -I FORWARD 1 -s  172.28.0.100 -d 172.28.0.105 -j DROP
              sudo iptables -I FORWARD 1 -s  172.28.0.105 -d 172.28.0.100 -j DROP
            execute: |
              docker compose exec -it client timeout 60 \
              bash -c 'until ping -W 1 -c 1 172.20.0.100 &>/dev/null; do true; done'
          - test_name: Basic flow
            setup: echo 'Noop'
            execute: |
              docker compose exec -it client timeout 60 \
              bash -c 'until ping -W 1 -c 1 172.20.0.100 &>/dev/null; do true; done'

    steps:
      - uses: actions/checkout@v4
      - name: Download built image artifacts
        uses: actions/download-artifact@v3
        with:
          name: images
          path: /tmp
      - name: Load images into docker
        run: |
          docker load --input /tmp/api.tar
          docker load --input /tmp/web.tar
          docker load --input /tmp/elixir.tar
          docker load --input /tmp/gateway.tar
          docker load --input /tmp/relay.tar
          docker load --input /tmp/client.tar
          docker image ls -a
      # FIXME: This doesn't use the Elixir cache, and so compiles every time
      - name: Seed database
        run:
          docker compose run elixir /bin/sh -c 'cd apps/domain && mix ecto.seed'
      - name: Start docker compose in the background
        run: |
          docker compose pull
          docker compose up -d \
            api \
            web \
            client \
            relay \
            gateway
      - name: Setup ${{ matrix.test_name }} test
        run: ${{ matrix.setup }}
      - name: Execute ${{ matrix.test_name }} test
        run: ${{ matrix.execute }}
      - name: Show Client logs
        if: "!cancelled()"
        run: docker compose logs client
      - name: Show Relay logs
        if: "!cancelled()"
        run: docker compose logs relay
      - name: Show Gateway logs
        if: "!cancelled()"
        run: docker compose logs gateway
      - name: Show API logs
        if: "!cancelled()"
        run: docker compose logs api
      - name: Show httpbin logs
        if: "!cancelled()"
        run: docker compose logs httpbin

  push-images:
    needs: integration-tests
    runs-on: ubuntu-latest
    matrix:
      image_name:
        - api
        - web
        - relay
        - gateway
    env:
      GCP_PROJECT: firezone-staging
      GCP_REGISTRY: us-east1-docker.pkg.dev
    steps:
      - id: auth
        uses: google-github-actions/auth@v1
        with:
          token_format: access_token
          workload_identity_provider: "projects/397012414171/locations/global/workloadIdentityPools/github-actions/providers/github-actions"
          service_account: "github-actions@github-iam-387915.iam.gserviceaccount.com"
          export_environment_variables: false
      - name: Change current gcloud account
        run: gcloud --quiet config set project ${{ env.GCP_PROJECT }}
      - name: Login to Google Artifact Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.GCP_REGISTRY }}
          username: oauth2accesstoken
          password: ${{ steps.auth.outputs.access_token }}
      - name: Push images
        if: ${{ github.ref == 'refs/heads/main' }}
        run:
          docker push ${{ env.GCP_REGISTRY }}/${{ env.GCP_PROJECT
          }}/firezone/${{ matrix.image_name }} --all-tags
