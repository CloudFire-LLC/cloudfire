name: Continuous Integration
on:
  pull_request:
  merge_group:
    types: [checks_requested]
  workflow_dispatch:
  workflow_call:

# Used to canonically tag images throughout this workflow, otherwise we get into
# cases on main where a build-push-action tries to push a built image to the
# public Docker Hub registry.
env:
  # mark:automatic-version
  VERSION: "1.20231001.0"
  GCP_PROJECT: firezone-staging
  GCP_REGISTRY: us-east1-docker.pkg.dev

jobs:
  elixir:
    uses: ./.github/workflows/elixir.yml
  rust:
    uses: ./.github/workflows/rust.yml
  kotlin:
    uses: ./.github/workflows/kotlin.yml
  swift:
    uses: ./.github/workflows/swift.yml
  static-analysis:
    uses: ./.github/workflows/static-analysis.yml
  terraform:
    uses: ./.github/workflows/terraform.yml
    secrets: inherit

  # We could build these in GCP with Cloud Build, but for now it's
  # less overhead to keep things in GH actions. See work on building these
  # in GCP with Cloud Build: https://github.com/firezone/firezone/pull/2234
  build-images:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - image_name: api
            ci_tags: firezone/api
            main_tags: |
              ${{ env.GCP_REGISTRY }}/${{ env.GCP_PROJECT }}/firezone/api:${{ env.VERSION }}
              ${{ env.GCP_REGISTRY }}/${{ env.GCP_PROJECT }}/firezone/api:${{ github.sha }}
            push: ${{ github.ref == 'refs/heads/main' }}
            cache_scope: elixir
            build-args: |
              APPLICATION_NAME=api
          - image_name: web
            ci_tags: firezone/gateway
            main_tags: |
              ${{ env.GCP_REGISTRY }}/${{ env.GCP_PROJECT }}/firezone/web:${{ env.VERSION }}
              ${{ env.GCP_REGISTRY }}/${{ env.GCP_PROJECT }}/firezone/web:${{ github.sha }}
            push: ${{ github.ref == 'refs/heads/main' }}
            cache_scope: elixir
            build-args: |
              APPLICATION_NAME=web
          - image_name: gateway
            ci_tags: firezone/gateway
            main_tags: |
              ${{ env.GCP_REGISTRY }}/${{ env.GCP_PROJECT }}/firezone/gateway:${{ env.VERSION }}
              ${{ env.GCP_REGISTRY }}/${{ env.GCP_PROJECT }}/firezone/gateway:${{ github.sha }}
            push: ${{ github.ref == 'refs/heads/main' }}
            cache_scope: rust
            build-args: |
              PACKAGE=gateway
          - image_name: relay
            ci_tags: firezone/relay
            main_tags: |
              ${{ env.GCP_REGISTRY }}/${{ env.GCP_PROJECT }}/firezone/relay:${{ env.VERSION }}
              ${{ env.GCP_REGISTRY }}/${{ env.GCP_PROJECT }}/firezone/relay:${{ github.sha }}
            push: ${{ github.ref == 'refs/heads/main' }}
            cache_scope: rust
            build-args: |
              PACKAGE=relay
          - image_name: client
            ci_tags: firezone/client
            main_tags:
            push: false
            cache_scope: rust
            build-args: |
              PACKAGE=headless
          - image_name: elixir
            ci_tags: firezone/elixir
            main_tags:
            push: false
            cache_scope: elixir
            build-args: |
              APPLICATION_NAME=api
    permissions:
      contents: read
      id-token: write
    env:
      APPLICATION_NAME: ${{ matrix.image_name }}
    steps:
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - uses: actions/checkout@v4
      - id: auth
        uses: google-github-actions/auth@v1
        with:
          token_format: access_token
          workload_identity_provider: "projects/397012414171/locations/global/workloadIdentityPools/github-actions/providers/github-actions"
          service_account: "github-actions@github-iam-387915.iam.gserviceaccount.com"
          export_environment_variables: false
      - name: Change current gcloud account
        run: gcloud --quiet config set project ${GCP_PROJECT}
      - name: Login to Google Artifact Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.GCP_REGISTRY }}
          username: oauth2accesstoken
          password: ${{ steps.auth.outputs.access_token }}
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          platforms: linux/amd64
          build-args: ${{ matrix.build-args }}
          context: ${{ matrix.cache_scope }}/
          cache-from: type=gha,scope=${{ matrix.cache_scope }}
          cache-to:
            ${{ github.ref == 'refs/heads/main' &&
            format('type=gha,mode=max,scope={0}', matrix.scope) || '' }}
          file: ${{ matrix.cache_scope }}/Dockerfile
          push: ${{ matrix.push}}
          tags:
            ${{ github.ref == 'refs/heads/main' && matrix.main_tags ||
            matrix.ci_tags }}
          outputs: type=docker,dest=/tmp/${{ matrix.image_name }}.tar
      - name: Upload built images as artifacts
        uses: actions/upload-artifact@v3
        with:
          name: images
          path: /tmp/${{ matrix.image_name }}.tar

  integration-tests:
    needs: build-images
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - test_name: Relayed flow
            setup: |
              #  Disallow traffic between gateway and client container
              sudo iptables -I FORWARD 1 -s  172.28.0.100 -d 172.28.0.105 -j DROP
              sudo iptables -I FORWARD 1 -s  172.28.0.105 -d 172.28.0.100 -j DROP
            execute: |
              docker compose exec -it client timeout 60 \
              bash -c 'until ping -W 1 -c 1 172.20.0.100 &>/dev/null; do true; done'
          - test_name: Basic flow
            setup: echo 'Noop'
            execute: |
              docker compose exec -it client timeout 60 \
              bash -c 'until ping -W 1 -c 1 172.20.0.100 &>/dev/null; do true; done'

    steps:
      - uses: actions/checkout@v4
      - name: Download built image artifacts
        uses: actions/download-artifact@v3
        with:
          name: images
          path: /tmp
      - name: Load images into docker
        run: |
          docker load --input /tmp/api.tar
          docker load --input /tmp/web.tar
          docker load --input /tmp/elixir.tar
          docker load --input /tmp/gateway.tar
          docker load --input /tmp/relay.tar
          docker load --input /tmp/client.tar
          docker image ls -a
      - name: Seed database
        run:
          docker compose run elixir /bin/sh -c 'cd apps/domain && mix ecto.seed'
      - name: Start docker compose in the background
        run: |
          docker compose up -d \
            api \
            web \
            client \
            relay \
            gateway
      - name: Setup ${{ matrix.test_name }} test
        run: ${{ matrix.setup }}
      - name: Execute ${{ matrix.test_name }} test
        run: ${{ matrix.execute }}
      - name: Show Client logs
        if: "!cancelled()"
        run: docker compose logs client
      - name: Show Relay logs
        if: "!cancelled()"
        run: docker compose logs relay
      - name: Show Gateway logs
        if: "!cancelled()"
        run: docker compose logs gateway
      - name: Show API logs
        if: "!cancelled()"
        run: docker compose logs api
      - name: Show httpbin logs
        if: "!cancelled()"
        run: docker compose logs httpbin
