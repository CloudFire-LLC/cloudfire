import Image from "next/image";

<Image
  src="/images/nostalgia-show-hn.png"
  alt="Show HN"
  width={1412}
  height={168}
  className="mx-auto shadow rounded"
/>

<span className="font-semibold">Firezone comes from humble roots.</span>

When we [launched on Hacker News](https://news.ycombinator.com/item?id=28683231)
nearly two years ago, we never envisioned Firezone to be more than a simple tool
for managing your WireGuard configurations.

Firezone was born out of necessity. While WireGuard itself is a marvelous
engineering feat, it provides only the basic building blocks. Users wishing to
deploy WireGuard as a replacement for their existing VPN likely found themselves
building automation to distribute keys, manage users, configure routing tables,
and so on.

And in my day job I found myself doing just that. It wasn't particularly
difficult automation to build, but it was tedious and error-prone. Still, it was
worth the price of admission to reap the benefits of WireGuard. Colleagues and I
agreed though -- "wouldn't it be wonderful if a tool existed to do this for us?"

So after one particularly grueling project to refactor an ancient codebase to
remove a particularly large dependency that was essentially welded in (there's
always one, isn't there?), I decided it was time for something new.

I resigned, picked up a book on Elixir/Phoenix (rejoicing at the time I now had
to learn some new tech), and started building what ended up becoming the first
version of Firezone.

Fast-forward
[4,500 GitHub stars](https://github.com/firezone/firezone/stargazers), a Y
Combinator backed funding round, and
[130 releases](https://github.com/firezone/firezone/releases) later -- Firezone
has now grown into something more than just a self-hosted tool to manage your
WireGuard configurations.

There are now over <strong>3,000</strong> Firezone instances running in the wild
(possibly much more -- we allow users to
[disable telemetry](/docs/reference/telemetry)) securing private networks for
hobbyists, schools, non-profits, and businesses with hundreds of employees.

<Image
  src="/images/wai-7-2-23.png"
  alt="weekly active instances"
  width={600}
  height={600}
  className="mx-auto shadow rounded border border-neutral-200"
/>

To be clear, Firezone is successful in large part because WireGuard itself is
successful. In an industry brimming with enterprise security bloatware and
endless acronyms, WireGuard's a breath of fresh air. Every issue I've thought I
had with it turned out to be user error. How we ever got by without it is a
mystery to me.

But I could go on and on about WireGuard's strengths. Let's back up for a minute
-- what is a VPN, and why is one needed at all? Why is it used for remote
access?

To answer that we'll need to go back to the formation of the Internet itself.

You see, the early Internet was designed at a time where entities connecting to
it were largely trusted, and well, large. Connecting to the Internet was
expensive.

So when you connected your organization to the Internet and began receiving
packets, it was clear which entity it was from based on its allocated IPv4
address range. Since there were so few entities connected, it was clear who the
traffic was from. It was clear who to contact (and blame) in case any issues
arose. Identifying who you were communicating with was trivial.

But, as the Internet grew, and access to it became cheaper, more types of
entities could afford to connect. As more entities connected, the value
connecting to the Internet increased exponentially, and so more and more wanted
to connect. Smaller entities. Soon Internet Service Providers began offering
connections to mere individuals. At this point, there were so many entities on
the Internet that identifying the source of packets coming to you was no longer
trivial. Since you couldn't easily know who you were talking to, you couldn't
trust them.

And thus, firewalls were born. Firewalls keep packets out from entities you
don't wish to communicate with and let packets in from those you do.

<Image
  width={600}
  height={400}
  src="/images/firewall-block.svg"
  alt="firewall animation"
  className="mx-auto"
/>

And this worked great for some time. However, as the Internet grew, a problem
arose: Firewalls required you to know _in advance_ who you'd like to communicate
with. But as more entities connected, this wasn't always the case. Soon, it
became untenable to modify your firewall ruleset for each entity you wanted to
communicate with, and remove those with which you didn't.

So a clever solution was designed: what if we could dynamically add and remove
entities to the firewall ruleset? What if we

And thus, stateful firewalls were born. I should pause here and clarify that
these are sometimes confused with NAT device, but I won't get into that
distinction here. They're often the same device these days, but the fundamental
attribute of a stateful firewall is that it _remembers_ things in order to to
update its behavior dynamically, whereas for a NAT device this quality isn't
strictly true.

Stateful firewalls exist in nearly every consumer router and datacenter gateway
connected to the Internet today. They've been largely successful at serving
their intended purpose.

However (as you may have guessed), this wouldn't make for much of an interesting
post if we stopped there.

You see, there's still one fundamental problem with stateful firewalls,
particularly as it relates to remote access. For two-way communication to occur,
one entity (namely the one "behind" the firewall) must always initiate. This
means that entities outside the firewall can never communicate to those inside,
_even if the outside ones are trusted_.



Aside from being used for IP address ventriloquism in support of your favorite
regionally-locked Netflix content, VPNs have traditionally been used by
businesses to select allow remote access to private networks.

have been Building in the open isn't always easy, and you often get pulled in
many directions by users with requirements that seemingly contradict one
another. But we wouldn't build a product like this any other way -- we believe
better transparency ultimately leads to better security. That's why we're open
source, after all.

Being open source tends to imply some level of self-hosting, and Firezone has
been completely

- History
  - Show HN
  - Y Combinator
- Metrics
- Problem solved
  - Users
- The problem with the internet
  - Enter stateful firewalls
  - Enter zero trust
- ... But zero trust is still a bandaid
- Introducing Firezone 1.0
  - How it solves the problem
  - Who's it for initially
  - What's the timeline to GA
- Clarify 1.0 details
  - Distribution model: Self-hosting vs Cloud
  - Licensing
  - Pricing
- Early access CTAs
