import Alert from "@/components/DocsAlert";
import AsciinemaPlayer from "@/components/AsciinemaPlayer";
import Image from "next/image";
import Link from "next/link";

> [I would have thought](https://github.com/tauri-apps/tauri/issues/8631#issuecomment-1896717039)
> after more than 20 years of GUI paradigms, the major OSes would have made GUIs
> as nice to program as CLIs.

-- The author

> I thought so too at one point, until i got into working _on_ (instead of
> "with") a gui framework. Now I cry myself to sleep every night ðŸ¤·

-- A lead Tauri developer

---

When I joined Firezone around the end of 2023, we needed a GUI framework to port
the Firezone Client software to Windows. We
[chose Tauri over other frameworks](https://github.com/firezone/firezone/issues/2715)
because it was the fastest way to get the product working. Now Tauri is the
framework for both the Linux GUI Client and the Windows GUI Client, which share
all their GUI code.

[**Tauri**](https://tauri.app/) is "a framework for building tiny, blazingly
fast binaries for all major desktop platforms." It's like
[Electron](<https://en.wikipedia.org/wiki/Electron_(software_framework)>)
except:

- The backend is Rust, not node.js / C++
- The webview is provided by the OS, not bundled with the app
- Because it doesn't bundle Chromium, the apps are under 100 MB to download

The Firezone team already knew web programming, and our cross-platform
connection library `connlib` is written in Rust, so Tauri didn't present any
huge learning curve - It's just more Rust.

We considered several other frameworks and rejected them all for now:

| Framework                                                                 | Positives                                                  | Negatives                                                                                                    |
| ------------------------------------------------------------------------- | ---------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------ |
| [Qt](<https://en.wikipedia.org/wiki/Qt_(software)>)                       | I really liked it around 2013                              | Quality of Rust bindings unknown, difficult to package                                                       |
| [FLTK](https://en.wikipedia.org/wiki/FLTK)                                | I'm familiar with it, small binaries                       | Difficult to style, missing many features                                                                    |
| [GTK+](https://en.wikipedia.org/wiki/GTK)                                 | De facto standard Linux GUI                                | Quality of Rust bindings and Windows support unknown, the Firezone team is not experienced with it           |
| [windows-rs](https://crates.io/crates/windows)                            | Smallest possible binary size                              | Verbose, lots of unsafe code, confusing documentation, not portable to Linux at all                          |
| [native-windows-gui](https://crates.io/crates/native-windows-gui)         | Looked easy                                                | Not maintained                                                                                               |
| [WPF](https://en.wikipedia.org/wiki/Windows_Presentation_Foundation)      | Small binaries, I've used it before                        | Binding C# to Rust considered infeasible, assumed Rust and Linux support to be bad                           |
| [Electron](<https://en.wikipedia.org/wiki/Electron_(software_framework)>) | Same positives as Tauri, but even more popular             | Infamously large download sizes, not intended for use with Rust                                              |
| [Iced](https://github.com/iced-rs/iced)                                   | Smaller downloads and less RAM usage than Tauri / Electron | Hasn't caught on yet, had some trouble with compatibility when building in Ubuntu 20.04 and running in 22.04 |

# What's so good about Tauri?

## Tauri is easy to learn and use

Growth solves everything.

Software grows when it is easy to use. It attracts beginners, and turns
beginners into advanced users and contributors. Python became popular by
appealing to new programmers who needed to write small programs. JavaScript
became popular by being pre-installed in every web browser. C++ became popular
by being published before both of them.

Using Tauri, we got the Windows Client to MVP in about 2 months, including the
time needed for me to learn about `connlib`, and for the team to change our auth
flow from one that worked well on macOS to one that worked on all platforms.
This has been my first real project with Tauri.

Bringing the Linux GUI Client to MVP took another 4 months. This was longer
because Linux's security model required us to split the Client into two
processes, and because the Windows Client needed some changes to make the code
sharable.

(TODO: Screenshots of the Windows and Linux MVPs)

Tauri makes itself easy by shipping the `create-tauri-app` tool for setting up
boilerplate projects, and by having bundlers for Windows `.msi` installers and
Debian `.deb` packages that Just Work, at least for simple programs.

<AsciinemaPlayer
  src="/asciinema/tauri.cast"
  autoplay={false}
  rows={30}
  idleTimeLimit={3}
  preload={true}
/>

## We already use Rust and TypeScript

Firezone already uses Rust for our data plane (the Gateway, the Relay, and
`connlib`) and TypeScript for the website and admin portal, so we didn't have to
add another language like C++ or C# to the mix. I made a prototype of the GUI in
TypeScript, hooked it up to the Rust code, and then let another team member
polish and style it to match the website branding.

The TypeScript / JavaScript inside the web view can call into `async` Rust
functions, and from there we have access to the usual Tokio facilities like mpsc
channels, tasks, etc., to perform work before returning to JavaScript.

e.g. [`apply_advanced_settings`]() writes the new settings to disk using Tokio's
`fs` module, then sends them to the central `Controller` over a channel. If the
`Controller` is backed up for any reason, the TypeScript will asynchronously
wait on the Rust code.

[TypeScript calling the function (settings.ts#L84-L90)](https://github.com/firezone/firezone/blob/37b3bc2047f6918adecda4108708b9ba9f76b84b/rust/gui-client/src/settings.ts#L84-L90)

```ts
invoke("apply_advanced_settings", {
  settings: {
    auth_base_url: authBaseUrlInput.value,
    api_url: apiUrlInput.value,
    log_filter: logFilterInput.value,
  },
});
```

[The Rust implementation (settings.rs#L47-L61)](https://github.com/firezone/firezone/blob/37b3bc2047f6918adecda4108708b9ba9f76b84b/rust/gui-client/src-tauri/src/client/settings.rs#L47-L61)

```rust
#[tauri::command]
pub(crate) async fn apply_advanced_settings(
    managed: tauri::State<'_, Managed>,
    settings: AdvancedSettings,
) -> Result<(), String> {
    if managed.inner().inject_faults {
        tokio::time::sleep(Duration::from_secs(2)).await;
    }
    apply_inner(&managed.ctlr_tx, settings)
        .await
        .map_err(|e| e.to_string())?;

    Ok(())
}
```

Tauri automatically serializes and deserializes both ways as long as our types
implement the common `serde::{Deserialize, Serialize}` traits, which we
`derive`:

[settings.rs#L12](https://github.com/firezone/firezone/blob/37b3bc2047f6918adecda4108708b9ba9f76b84b/rust/gui-client/src-tauri/src/client/settings.rs#L12)

```rust
#[derive(Clone, Deserialize, Serialize)]
pub(crate) struct AdvancedSettings {
    pub auth_base_url: Url,
    pub api_url: Url,
    pub log_filter: String,
}
```

## Tauri comes with batteries included

The requirements for the beta Windows Client included:

- A system tray icon and menu
- Pop-up "toast" notifications such as "Firezone is connected"
- A plan for automatic updates
- A plan for a Linux port
- The ability to receive deep links from web browsers

Tauri has built-in modules for a
[system tray menu](https://docs.rs/tauri/1.6.7/tauri/struct.SystemTrayMenu.html),
[notifications](https://docs.rs/tauri/1.6.7/tauri/api/notification/struct.Notification.html),
and [self-updates](https://docs.rs/tauri/1.6.7/tauri/updater/index.html), and it
has a `.deb` [bundler for Linux](https://tauri.app/v1/api/config/#debconfig)
built in. For deep links we used
[tauri-plugin-deep-link](https://crates.io/crates/tauri-plugin-deep-link).

This made it easy to commit to Tauri - We knew that worst-case, we had
_something_ that would work for an MVP release.

Some of those "batteries" stayed in and some got replaced. We replaced the
default Tauri notifications on Windows with `tauri-winrt-notification`, we
rewrote the deep link code using `tauri-plugin-deep-link` as a reference, and we
haven't deployed self-updates yet. The system tray menu will be replaced
eventually too, but over the last 6 months Tauri's built-in features have saved
us lots of effort.

# How does Tauri work for us?

```text
Firezone Client
    |
    +------> Tokio
    |
    +------> connlib
    |
    +------> Tauri
```

The Firezone Client for Linux and Windows is a wrapper around our cross-platform
connection library `connlib`. We use [Tokio](https://github.com/tokio-rs/tokio),
the popular async runtime for Rust, to glue everything together, and then Tauri
provides the GUI and bundling.

## Tauri = TAO + WRY

```text
Tauri
  |
  +----> Tokio
  |
  +----> WRY
  |       |
  |       +----> WebView2 (Windows)
  |       |
  |       +----> webkit2gtk (Linux)
  |
  +----> TAO
          |
          +----> Win32 (Windows)
          |
          +----> GTK+ (Linux)
```

Tauri internally uses Tokio too. Below that, it's built on
[WRY](https://github.com/tauri-apps/wry) and
[TAO](https://github.com/tauri-apps/tao), two sibling projects also maintained
by the Tauri Programme.

TAO is a "window creation library". It opens windows and runs a minimal event
loop, just enough for WRY, the "webview rendering library", to spawn a webview
inside each window and run the GUI.

WRY uses platform-specific web views like `webkit2gtk` on Linux and
[WebView2](https://developer.microsoft.com/en-us/microsoft-edge/webview2) on
Windows.

WebView2 and WebKit2 are similar from a bird's-eye view. There's a main UI
process, such as the Firezone Client or a web browser, and then multiple worker
processes to render web views. In a web browser these processes might map to
individual tabs. In Tauri they map to individual windows.

```text
UI process
    |
    +--------> WebContent process
    |
    +--------> WebContent process
    |
    +--------> WebContent process
```

(Paraphrased from
[webkit.org](https://docs.webkit.org/Getting%20Started/Introduction.html#what-is-webkit))

The two engines are essentially cousins as well:

- In 2001, [Apple forked KHTML](https://en.wikipedia.org/wiki/WebKit#Origins) to
  make WebKit, the browser engine for Safari.
- In 2008, Chromium 1.0 released, based on a
  [multi-process branch of WebKit](<https://en.wikipedia.org/wiki/Chromium_(web_browser)#Architecture>)
- In 2013, Chromium forked WebKit and named it
  [Blink](<https://en.wikipedia.org/wiki/Blink_(browser_engine)>)
- In 2015, Microsoft released
  [Edge](https://en.wikipedia.org/wiki/Microsoft_Edge) using an engine that no
  longer exists
- In 2020, Microsoft released the new Edge, built atop Chromium, as well as
  [WebView2](https://blogs.windows.com/msedgedev/2020/10/19/edge-webview2-general-availability/)

So WebView2 is an API for Microsoft Edge, which is Google Chromium, based on
Google Blink, which was WebKit, meant for Apple Safari, originally KDE KHTML.

Firezone is [Konqueror](https://en.wikipedia.org/wiki/Konqueror).

<Link href="/images/blog/using-tauri/konqueror.png" target="_blank">
  <Image
    width={1024}
    height={768}
    src="/images/blog/using-tauri/konqueror.png"
    alt="The primordial soup from which the Web evolved"
  />
</Link>

_The primordial soup from which the Web evolved_

(Source:
https://en.wikipedia.org/wiki/K_Desktop_Environment_2#/media/File:KDE_2.2.2.png)

## Bundling ðŸ“¦

Tauri's bundlers were a huge selling point for us. It turns out `.deb` packages
are easy to make, but making a good `.msi` installer requires some boilerplate.
We originally wanted to ship a portable single-file executable, but two
requirements made it impractical on both platforms:

- Controlling DNS and running the Firezone tunnel requires admin / sudo
  privileges. We don't want admin privilege to be a requirement for day-to-day
  use of Firezone, so we install a service that has the right privileges and
  takes commands from the GUI. Installing a service from a portable executable
  makes it not portable.
- The webview libraries are shared on both platforms, so if the system doesn't
  have them installed, we'd have to take admin privilege to install them on the
  first run of the GUI, which is not convenient, and doesn't match how Debian /
  Ubuntu want to install packages.

For Linux (Ubuntu), Tauri creates a `.deb` package. This package references
webkit2gtk, so `apt` will install it for us when Firezone is installed, share it
with other software on the system, and upgrade it when security patches are
released.

```text
deb package
    |
    +----> firezone-client-gui
    |
    +----> systemd service
    |
    +----> HTML+JS+CSS assets
    |
    +----> dependency on webkit2gtk
```

For Windows, Tauri creates an `.msi` installer, which automatically downloads
and installs WebView2 if the system doesn't have it already. Windows 11 systems
have WebView2 pre-installed, and just like `apt` on Ubuntu, we let Windows take
responsibility for security updates.

```text
MSI installer
    |
    +----> firezone-client-gui.exe
    |
    +----> Windows service
    |
    +----> HTML+JS+CSS assets
    |
    +----> WebView2 downloader
```

Firezone Client 1.0.5 is **12 MB on Linux** and **8 MB on Windows**, much
smaller than the default ~100 MB for Electron, and still a bit smaller than the
~35 MB achievable with
[electron-builder](https://github.com/electron-userland/electron-builder).

# If Tauri is so great, why did the Linux port take twice as long as Windows?

The Linux port took twice as long because running a GUI with `sudo` in Linux
doesn't seem to work, and we need root permissions to control DNS.

On Windows, the early releases were just one process running with admin
privilege. (Plus the WebView worker processes)

```text
+---------------------------+
|    Tauri GUI process      |
|                           |
|   +-------------------+   |
|   |   Secure tunnel   |   |
|   +-------------------+   |
+---------------------------+
```

When we ported that to Linux, everything broke.

The tray icon
[didn't appear on some Ubuntu versions](https://github.com/firezone/firezone/issues/4053),
so we couldn't click "Sign in", and when it did appear, we
[couldn't open a browser anyway](https://github.com/firezone/firezone/issues/4103),
because the desktop is expecting us to be a normal user and the GUI was actually
`root`.

So we gave in and switched to 2 top-level processes, a refactor we'd planned to
do _after_ the Linux GUI MVP:

- A GUI running as a non-root user, and
- A systemd service running as root, with lots of sandboxing.

```text
+-----------------------+                                             +-------------------+
|   Tauri GUI process   | <------ Inter-process communication ------> |   Secure tunnel   |
+-----------------------+                                             +-------------------+
```

The GUI controls the tunnel service via named pipes on Windows and Unix domain
sockets on Linux.

This is a security win for two reasons. First, it puts a boundary between a
million lines of web engine code and our cryptography code. Second, systemd's
sandboxing in
[firezone-client-ipc.service](https://github.com/firezone/firezone/blob/37b3bc2047f6918adecda4108708b9ba9f76b84b/rust/gui-client/src-tauri/deb_files/firezone-client-ipc.service)
means that the code running as root can't accidentally
[read your email](https://xkcd.com/1200/),
[delete the entire filesystem](https://hackaday.com/2024/01/20/how-a-steam-bug-once-deleted-all-of-someones-user-data/),
or even change the time on the system clock.

We copied this architecture to Windows, where it coincidentally fixed a bug
where
[our DNS control didn't deactivate](https://github.com/firezone/firezone/issues/4899)
if the system powered off suddenly or Firezone was force-stopped.

Not all the sandboxing is on Windows, but on both platforms it is a convenience
win because normal users don't need special privileges, and a bug-fixing win
because the service can clean up Firezone's DNS control if the GUI crashes or
the computer suddenly loses power.

So we arrived at where we wanted to be, even though the steps weren't all taken
in the order we originally planned.

# What non-Tauri issues did we have?

## Web views use a whole bunch of RAM

<Image
  width={1598}
  height={952}
  src="/images/blog/using-tauri/lots-of-ram.png"
  alt="Windows Task Manager showing that the webviews need about 100 MB of RAM to do nothing"
/>

The GUI uses about 100 MB of RAM even with all windows hidden. This seems to be
the minimum for keeping the web view process alive. It's okay for an MVP, but
it's still 5% of the 2 GB needed to run an Ubuntu VM, just to run a GUI that
will be closed most of the time.

We can't fix this right now, but we have at least 3 long-term options:

1. Try closing the windows instead of just hiding them
2. Only use the main GUI process to run the tray menu, and keep the Tauri
   windows in a subprocess that we can stop and restart as needed
3. Switch away from Tauri entirely. Iced uses about half as much RAM, but it has
   compatibility issues on Ubuntu at time of writing. If we can bundle GTK+ for
   Windows, that could also be an option.

Hopefully some of that 100 MB is code pages we can share with Edge and other
WebView2 apps, but I'm guessing a lot of it is renderer overhead or JS engine
overhead.

## Ubuntu forwards and backwards compatibility is hard

Ubuntu 20.04 ships `webkit2gtk` version 4.0. Ubuntu 22.04 ships version 4.0 and
4.1. Ubuntu 24.04 only ships 4.1.

It's not possible to link with both, so it's impractical to make one exe that
runs on all 3 of the Ubuntu versions we'd like to support. For now we are not
supporting 24.04 yet, and in the future we may give it a separate package. This
is common in Linux programs that use anything more than the most common
libraries.

Tauri does offer an AppImage option to bundle the webview, but this increases
the download size from ~10 MB to ~100 MB, and it seems we can't install our
background service if we're running from an AppImage, since they're meant to
work without installation.

Switching to FLTK or GTK+ might fix this, but it's hard to say without
researching.

## WebView2 just doesn't install sometimes

<Image
  width={1230}
  height={464}
  src="/images/blog/using-tauri/webview-install-hang.png"
  alt="The WebView2 installer just hanging in CI for some reason"
/>

https://github.com/firezone/firezone/pull/4981

This is an upstream issue with WebView2 for Windows. Sometimes the installer
times out in our GitHub CI runners and it isn't clear why.

# What Tauri-related issues did we have?

Overall, we like Tauri. This section is long because there are lots of little
details about things that went wrong. "It's good" is shorter than "We had
trouble because..."

## The Tauri directory layout is odd

The root of a Tauri project, such as
[`/rust/gui-client` in the Firezone repo](https://github.com/firezone/firezone/tree/2a1187bd9c4d12960ef0000df1b6bd9bb361bf10/rust/gui-client),
has two subdirectories: `src` and `src-tauri`. The entire Rust project is
contained in `src-tauri`, and the `src` directory contains files for the web
view. `Cargo.toml` and `tauri.conf.json` are in `src-tauri`. I find this
confusing. I think Tauri's primary use case is to wrap up web apps into native
apps, so the Rust code is isolated in `src-tauri`, and the project is supposed
to be an NPM project that incidentally contains a Rust wrapper.

We think of the Firezone Client as a Rust program that incidentally uses
HTML+JS+CSS for the GUI, so this layout is backwards for us. One would expect a
top-level `/Cargo.toml`, with the Rust code under `/src`, and the web files
under `/src-web` or something. Maybe there's a reason for the layout Tauri uses.

## Tauri's deb bundler is not very customizable

To install the systemd service on Linux, we need the deb package to have
[post-install](https://github.com/firezone/firezone/blob/2a1187bd9c4d12960ef0000df1b6bd9bb361bf10/rust/gui-client/src-tauri/deb_files/postinst)
and
[pre-remove](https://github.com/firezone/firezone/blob/2a1187bd9c4d12960ef0000df1b6bd9bb361bf10/rust/gui-client/src-tauri/deb_files/prerm)
scripts. `dpkg` doesn't install these in the filesystem, it runs them when
adding or removing a package, and then it deletes them. Tauri allows us to
bundle arbitrary files for installation in the filesystem, and we use that to
install
[the systemd service and a system group](https://github.com/firezone/firezone/blob/2a1187bd9c4d12960ef0000df1b6bd9bb361bf10/rust/gui-client/src-tauri/tauri.conf.json#L23-L26),
but it doesn't have any hook for these special scripts.

So in Firezone's build process, we
[delete Tauri's deb, add our scripts to the intermediate files Tauri left, and then finish the bundling ourselves.](https://github.com/firezone/firezone/blob/2a1187bd9c4d12960ef0000df1b6bd9bb361bf10/rust/gui-client/build.sh#L20-L39)

I'm surprised these scripts are not in Tauri's use cases. On Windows, Tauri
allows us to install and configure our background service by
[overriding the Wix files](https://github.com/firezone/firezone/blob/2a1187bd9c4d12960ef0000df1b6bd9bb361bf10/rust/gui-client/src-tauri/tauri.conf.json#L44-L45)
that generate the MSI.

`cargo-deb`
[does allow these scripts](https://github.com/kornelski/cargo-deb?tab=readme-ov-file#packagemetadatadeb-options),
but Tauri's bundler is based on
[`cargo-bundle`](https://github.com/burtonageo/cargo-bundle) instead, which
doesn't appear to support the scripts.

## The tray menu works, but it's odd

In Windows, you can't left-click on the tray menu. Tauri doesn't seem to fire
any event for it. This is not a limitation of Windows, so I'm not sure why Tauri
only allows right clicks.

On GNOME, if the menu is too long and the screen is too short, you can't open
submenus. If the menu is barely too long, the submenus open but they're squashed
into a tiny scroll view that doesn't look like a submenu:

<Link href="/images/blog/using-tauri/squashed-menu.png" target="_blank">
  <Image
    width={888}
    height={724}
    src="/images/blog/using-tauri/squashed-menu.png"
    alt="A very long menu displayed in GNOME, with the submenu being squashed"
  />
</Link>

On Windows, the submenus look like submenus:

<Link href="/images/blog/using-tauri/good-menu.png" target="_blank">
  <Image
    width={1048}
    height={654}
    src="/images/blog/using-tauri/good-menu.png"
    alt="A very long menu displayed in GNOME, with the submenu being squashed"
  />
</Link>

Also in GNOME, clicking on a notification runs another instance of the app.
Maybe this is intended to activate the app, but it doesn't seem to happen on
Windows. (On Windows, we already worked around Tauri's default notifications
with
[tauri-winrt-notification](https://crates.io/crates/tauri-winrt-notification),
since Tauri's default notifications aren't clickable.) The second instance
doesn't get any obvious environment variable or argument to hint that it was
launched from a notification, so we show a generic "Firezone is already running"
error instead of doing anything useful.

## Tauri apps can't exit gracefully

Not kidding. From `main` you decide when to start Tauri, but the only way to
exit Tauri is to let it call `std::process::exit`.

This is implemented down in `tao`, Tauri's windowing library, for both
[Linux](https://github.com/tauri-apps/tao/blob/f9f81f2fd761c60abb5b46a6469864562a811c6d/src/platform_impl/linux/event_loop.rs#L913)
and
[Windows](https://github.com/tauri-apps/tao/blob/f9f81f2fd761c60abb5b46a6469864562a811c6d/src/platform_impl/windows/event_loop.rs#L219).

This might be due to some platform-specific limitation, such as Windows'
`WinMain` function or the fact that some OSes require all GUI-related function
calls to happen on "the main thread", or at least on a single thread.

`tao` is a fork of `winit`, and `winit` is able to return from
[its run function](https://docs.rs/winit/latest/winit/event_loop/struct.EventLoop.html#method.run_app)
on desktop.

The
[`run_iteration` function](https://docs.rs/tauri/1.6.6/tauri/struct.App.html#method.run_iteration)
should be able to handle this, but instead it busy-loops.

When asked about these issues, lead Tauri developer Fabian said he also expects
better from the underlying OSes and this causes him to
["cry (himself) to sleep at night ðŸ¤·"](https://github.com/tauri-apps/tauri/issues/8631#issuecomment-1898328992)
Me too, Fabian, me too.

## Setting binary names is tricky

On Linux our GUI is named `firezone-client-gui`, and so is our package.

We want:

1. The `.desktop` file to display our name as "Firezone Client", so it's
   human-friendly,
1. The package to be `firezone-client-gui`, so that it's distinct from our CLI
   Client
1. The GUI binary to be `/usr/bin/firezone-client-gui`,
1. And the service binary to be
   `/usr/lib/$ARCH/dev.firezone.client/firezone-client-ipc`, to keep it out of
   `$PATH`.

But Tauri's default is to name the first 3 the same and to put all binaries in
`/usr/bin`. We could fix this by tearing apart the `.deb` and rebuilding it, as
we do for the post-install script, but it would take more work.

This is a case where Tauri doesn't quite meet the "Easy things are simple, hard
things are possible" principle. In this case, easy things are simple, and hard
things require us to work around Tauri.

## Initializing Tauri is flaky in CI... maybe?

https://github.com/firezone/firezone/issues/3972#issuecomment-2010728424

At first we tried to initialize as much of the program as possible before
starting Tauri, and then move objects into the Tauri context. But we hit this
issue, which appears to be a race in initializing the GTK+ event loop or
something. It's arcane stuff 3 layers below us (Tauri, then `tao`, then GTK+) in
unsafe C code, so the workaround for now is to initialize Tauri immediately and
do all our own setup within the Tauri context.

It may not be Tauri's fault, but it's disappointing because it's nice to keep
control of `main` longer before handing control to Tauri and doing everything
inside callbacks.

# Conclusion

Sometimes Tauri feels like the training wheels on a bicycle. It gets you
started, then after a certain point you can't build on it, you just have to
replace parts of it.

But those training wheels are _very_ nice to have on a brand-new GUI project.

The final word is, **we like Tauri.**
