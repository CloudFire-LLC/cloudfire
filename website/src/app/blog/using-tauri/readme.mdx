import Alert from "@/components/DocsAlert";
import AsciinemaPlayer from "@/components/AsciinemaPlayer";
import Image from "next/image";
import Link from "next/link";

[Tauri](https://tauri.app/) is "a framework for building tiny, blazingly fast
binaries for all major desktop platforms."

We
[chose Tauri over other frameworks](https://github.com/firezone/firezone/issues/2715)
because it was the fastest way to get the product working on Linux and Windows.
The team already has experience with HTML/JS/CSS, and our cross-platform
connection library `connlib` is written in Rust.

We might consider other frameworks in the future. These ones are rejected for
now:

- **Qt** - Quality of Rust bindings unknown, typically distributed with lots of
  separate DLL files.
- **FLTK** - Difficult to style, very "batteries not included"
- **GTK+** - Quality of Rust bindings unknown, quality of Windows support
  unknown
- **Win32** - Verbose, complicated, documentation is confusing, not portable to
  Linux
- **native-windows-gui** - Not popular enough / not maintained
- **WinForms / WPF** - Binding to C# assumed to be difficult
- **Electron** - Huge downloads, quality of Rust bindings unknown
- **Iced** - Nobody on the team has experience with it

# What is good about Tauri?

## Tauri is easy to learn and use

Using Tauri for the first time, I got the Windows Client to MVP in about 2
months, and the Linux Client to MVP in another 4 months. Linux took longer
because its security model required us to split the Client into a privileged
tunnel service and un-privileged GUI.

(TODO: Screenshots of the Windows and Linux MVPs)

Software that is easy for beginners to use ends up attracting beginners and
turning them into experienced users and contributors. The Rust language
deliberately took advantage of this, shipping the beginner-friendly Cargo
package manager from Rust 1.0 and shipping Clippy a few years later in 2018.

Tauri does the same thing, shipping the `tauri-cli` tool for setting up
boilerplate projects, and package bundlers for Windows `.msi` installers and
Debian `.deb` packages that Just Work, at least for simple programs.

<AsciinemaPlayer
  src="/asciinema/tauri.cast"
  autoplay={false}
  rows={30}
  idleTimeLimit={3}
  preload={true}
/>

## Tauri integrates with Rust and TypeScript

Firezone already uses Rust for the data plane (the Gateway, the Relay, and
`connlib`) and TypeScript for the website and admin portal. I don't know much
web design, so using TypeScript allowed me to make a rough prototype of the GUI
and then let other team members polish and style it to match the website
branding.

JavaScript inside the web view can call into `async` Rust functions (TODO: Code
example), and from there we can use `tokio`'s mpsc channels to send events to a
central controller task. (TODO: Code)

## Tauri comes with batteries included

The requirements for the beta Windows Client included:

- A system tray icon and menu
- Pop-up "toast" notifications such as "Firezone is connected"
- A plan for automatic updates in the future
- A plan for a Linux port in the future
- The ability to receive deep links from web browsers

Tauri has built-in modules for a
[system tray menu](https://docs.rs/tauri/1.6.7/tauri/struct.SystemTrayMenu.html),
[notifications](https://docs.rs/tauri/1.6.7/tauri/api/notification/struct.Notification.html),
and [self-updates](https://docs.rs/tauri/1.6.7/tauri/updater/index.html), and it
has a `.deb` bundler built in. For deep links we used
[tauri-plugin-deep-link](https://crates.io/crates/tauri-plugin-deep-link).

This made it easy to commit to Tauri - We knew that worst-case, we had
_something_ that would work for a beta release. We ended up replacing the Tauri
notifications on Windows with `tauri-winrt-notification`, rewriting the deep
link code using `tauri-plugin-deep-link` as a reference, and not deploying
self-updates yet.

The system tray menu will be replaced too eventually, but until then Tauri saved
us a lot of effort - We only have
[~150 lines of code](https://github.com/firezone/firezone/blob/879fdeea1919f879e10e105f92bbf488731628ae/rust/gui-client/src-tauri/src/client/gui/system_tray_menu.rs)
related to that menu, and we didn't have to shop around for another crate to get
it working in the same event loop.

# Why did the Linux port take twice as long as Windows?

The Linux port took twice as long as Windows because running a GUI with `sudo`
in Linux just doesn't seem to work right, and we need root permissions to
control DNS.

On Windows, we got away with a single top-level GUI process that had admin
privilege. Linux seems to be stricter about root privileges, and when we ported
the Windows Client to Linux, it didn't work.

The tray icon
[didn't show up on all platforms](https://github.com/firezone/firezone/issues/4053),
so we couldn't sign in, and when we tried, we
[couldn't open a browser](https://github.com/firezone/firezone/issues/4103)

There might be some tricks with environment variables to convince a root Linux
GUI to talk to X11 / Wayland, but we gave up on that and switched to 2 top-level
processes: A GUI running as the normal user, and a systemd service. This puts a
boundary between the millions of lines of WebKit and JavascriptCore code in the
GUI, and the cryptography and connection code in `connlib`, so it may improve
security. It also allows non-sudo users to run the GUI, and it allows the tunnel
service to clean up the connection even if the GUI panics or crashes.

Unfortunately this process splitting slowed down development, and the
requirement to have a systemd service means that we can't have a single-file
portable exe anymore (without extra effort), but this is the architecture we're
planning to support.

# What non-Tauri issues did we have?

## Web views use a lot of RAM

The GUI uses about 100 MB of RAM even with all windows hidden. This seems to be
the minimum for keeping the web view process alive. It's okay for an MVP, but
it's still 5% of the 2 GB needed to run an Ubuntu VM, just to run a GUI that
isn't even needed for Firezone's core functions.

We might be able to fix this in the future by closing the windows instead of
just hiding them, by separating the tray icon from the main GUI process, or by
switching frameworks entirely. Iced uses about half as much RAM, but at time of
writing an Iced binary compiled on Ubuntu 20.04 didn't work perfectly on 22.04.

And there is some solace that we're theoretically able to share code pages with
other web view processes, we're not loading our own entire copy of Chromium like
Electron does.

(TODO: Task manager screenshot)

## Ubuntu forwards and backwards compatibility is hard

Ubuntu 20.04 ships `webkit2gtk` version 4.0. Ubuntu 22.04 ships version 4.0 and
4.1. Ubuntu 24.04 only ships 4.1.

It's not possible to link with both, so it's impractical to make one exe that
runs on all 3 of the Ubuntu versions we'd like to support. For now we are not
supporting 24.04 yet, and in the future we may give it a separate package. This
is common in Linux programs that use anything more than the most common
libraries.

Tauri does offer an AppImage option to bundle the webview, but this increases
the download size from ~10 MB to ~100 MB, and it seems we can't install our
background service if we're running from an AppImage, since they're meant to
work without installation.

Switching to FLTK or GTK+ might fix this, but it's hard to say without
researching.

## WebView2 just doesn't install sometimes

https://github.com/firezone/firezone/pull/4981

This is an upstream issue with WebView2 for Windows. Sometimes the installer
times out in our GitHub CI runners and it isn't clear why.

TODO: Screenshot or log paste

# What Tauri-related issues did we have?

Overall, I like Tauri a lot. This section is longer because there are lots of
little details. "It's good" is shorter than "We had trouble because..."

## The Tauri directory layout is odd

The root of a Tauri project, such as
[`/rust/gui-client` in the Firezone repo](https://github.com/firezone/firezone/tree/2a1187bd9c4d12960ef0000df1b6bd9bb361bf10/rust/gui-client),
has two subdirectories: `src` and `src-tauri`. The entire Rust project is
contained in `src-tauri`, and the `src` directory contains files for the web
view. `Cargo.toml` and `tauri.conf.json` are in `src-tauri`. I find this
confusing. I think Tauri's primary purpose is to wrap up web apps into native
apps, so the Rust code is isolated in `src-tauri`, and the project is supposed
to be an NPM project that incidentally contains a Rust wrapper.

I think of the Firezone Client as a Rust program that incidentally uses
HTML+JS+CSS for the GUI, so this layout is backwards to me. I would have
expected a top-level `/Cargo.toml`, with the Rust under `/src`, and the web
files under `/src-web` or similar. Maybe there's a reason for this, but I'm not
aware of it.

## Tauri's deb bundler is not very customizable

To install the systemd service on Linux, we need the deb package to have
[post-install](https://github.com/firezone/firezone/blob/2a1187bd9c4d12960ef0000df1b6bd9bb361bf10/rust/gui-client/src-tauri/deb_files/postinst)
and
[pre-remove](https://github.com/firezone/firezone/blob/2a1187bd9c4d12960ef0000df1b6bd9bb361bf10/rust/gui-client/src-tauri/deb_files/prerm)
scripts. `dpkg` doesn't install these in the filesystem, it runs them when
adding or removing a package, and then it deletes them. Tauri allows us to
bundle arbitrary files for installation in the filesystem, and we use that to
install
[the systemd service and a system group](https://github.com/firezone/firezone/blob/2a1187bd9c4d12960ef0000df1b6bd9bb361bf10/rust/gui-client/src-tauri/tauri.conf.json#L23-L26),
but it doesn't have any hook for these special scripts.

So in Firezone's build process, we
[delete Tauri's deb, add our scripts to the intermediate files Tauri left, and then finish the bundling ourselves.](https://github.com/firezone/firezone/blob/2a1187bd9c4d12960ef0000df1b6bd9bb361bf10/rust/gui-client/build.sh#L20-L39)

I'm surprised these scripts are not in Tauri's use cases. On Windows, Tauri
allows us to install and configure our background service by
[overriding the Wix files](https://github.com/firezone/firezone/blob/2a1187bd9c4d12960ef0000df1b6bd9bb361bf10/rust/gui-client/src-tauri/tauri.conf.json#L44-L45)
that generate the MSI.

`cargo-deb`
[does allow these scripts](https://github.com/kornelski/cargo-deb?tab=readme-ov-file#packagemetadatadeb-options),
but Tauri's bundler is based on
[`cargo-bundle`](https://github.com/burtonageo/cargo-bundle) instead, which
doesn't appear to support the scripts.

## The tray menu works, but it's odd

In Windows, you can't left-click on the tray menu. Tauri doesn't seem to fire
any event for it. This is not a limitation of Windows, so I'm not sure why Tauri
only allows right clicks.

On GNOME, if the menu is too long and the screen is too short, you can't open
submenus. (TODO: Screenshots)

Also in GNOME, clicking on a notification runs another instance of the app. I
assume this is intended to activate the app, but it doesn't seem to happen on
Windows. (On Windows, we already worked around Tauri's default notifications
with
[tauri-winrt-notification](https://crates.io/crates/tauri-winrt-notification),
since Tauri's default notifications aren't clickable.) I'm not sure if the
second instance gets any environment variable or argument to hint that it was
launched from a notification, so we show a generic "Firezone is already running"
error instead of doing anything useful.

## Tauri apps can't exit gracefully

Not kidding. From `main` you decide when to start Tauri, but the only way to
exit Tauri is to let it call `std::process::exit`.

This is implemented down in `tao`, Tauri's windowing library, for both
[Linux](https://github.com/tauri-apps/tao/blob/f9f81f2fd761c60abb5b46a6469864562a811c6d/src/platform_impl/linux/event_loop.rs#L913)
and
[Windows](https://github.com/tauri-apps/tao/blob/f9f81f2fd761c60abb5b46a6469864562a811c6d/src/platform_impl/windows/event_loop.rs#L219).

I first suspected this is due to some platform-specific limitation, such as
Windows' `WinMain` function or the fact that some OSes require all GUI-related
function calls to happen on "the main thread", or at least on a single thread.

`tao` is a fork of `winit`, and `winit` is able to return from
[its run function](https://docs.rs/winit/latest/winit/event_loop/struct.EventLoop.html#method.run_app)
on desktop.

The
[`run_iteration` function](https://docs.rs/tauri/1.6.6/tauri/struct.App.html#method.run_iteration)
should be able to handle this, but instead it busy-loops.

When asked about these issues, lead Tauri developer Fabian said he also expects
better from the underlying OSes and this causes him to
["cry (himself) to sleep at night 🤷"](https://github.com/tauri-apps/tauri/issues/8631#issuecomment-1898328992)
Me too, Fabian, me too. /s

## Setting binary names is tricky

On Linux our GUI is named `firezone-client-gui`, and so is our package.

I want:

1. The `.desktop` file to display our name as "Firezone Client", so it's
   human-friendly,
1. The package to be `firezone-client-gui`, so that it's distinct from our CLI
   Client
1. The GUI binary to be `/usr/bin/firezone-client-gui`,
1. And the service binary to be
   `/usr/lib/$ARCH/dev.firezone.client/firezone-client-ipc`, to keep it out of
   `$PATH`.

But Tauri's default is to name the first 3 the same and to put all binaries in
`/usr/bin`. I can fix this by tearing apart the `.deb` and rebuilding it, as I
did for the post-install script, but it will take more work.

This is a case where Tauri doesn't quite meet the "Easy things are simple, hard
things are possible" principle. In this case easy things are simple and hard
things require working around Tauri.

## Initializing Tauri is flaky in CI... maybe?

https://github.com/firezone/firezone/issues/3972#issuecomment-2010728424

At first I tried to initialize as much as the program as possible, then start
Tauri and move objects into the Tauri context. But we hit this issue, which
appears to be a race in initializing the GTK+ event loop or something. It's
arcane stuff 3 layers below us (Tauri, then `tao`, then GTK+) in unsafe C code,
so the workaround for now is to initialize Tauri immediately and do all our own
setup within the Tauri context.

It may not be Tauri's fault, but it's disappointing because I liked having
control of `main` for as long as possible before starting up Tauri.

# Conclusion

So what's the verdict?

**I like Tauri a lot, and I'll use it again.** It saved me a lot of work.

But at times it feels like training wheels. When we need more than the basics,
we work around it instead of working with it.

The folks at Tauri have been working on a 2.x release for quite a while, and I
assume it may fix some of these issues. But if the issues that are below Tauri
or inherent to Tauri's design turn out to be big issues, eventually we might
replace it.
